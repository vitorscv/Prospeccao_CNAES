\"\"\"\n+Aba de planejamento de rotas para representantes (vers√£o melhorada).\n+Suporta: rota autom√°tica por densidade ou rota existente (lista de cidades),\n+dedupe por matriz e export do roteiro.\n+\"\"\"\n+from __future__ import annotations\n+\n+import streamlit as st\n+import pandas as pd\n+from typing import List, Tuple\n+\n+from src.config.scoring_config import SEGMENTOS_PANTEX\n+from src.database.estabelecimentos_repository import (\n+    buscar_leads_enriquecidos,\n+    dedupe_leads_por_cnpj_basico,\n+)\n+from src.database.repository import buscar_dados_dashboard_executivo, listar_cidades_do_banco\n+from src.services.scoring_service import qualificar_leads\n+from src.services.route_service import planejar_rota\n+from src.services.excel_service import gerar_excel_roteiro\n+from src.ui.icons import Icons\n+\n+\n+def render_tab_rota():\n+    \"\"\"Renderiza a aba de planejamento de rotas.\"\"\"\n+    st.header(Icons.ABA_PROSPECT + \" Planejador de Rota do Representante\")\n+    st.caption(\"Forne√ßa uma rota (lista de cidades) ou deixe o sistema gerar automaticamente.\")\n+\n+    # ===== SE√á√ÉO 1: CONFIGURA√á√ÉO DA ROTA =====\n+    st.markdown(\"### \" + Icons.BUSCAR + \" Configura√ß√£o da Rota\")\n+    col1, col2 = st.columns(2)\n+\n+    with col1:\n+        cidade_base = st.text_input(\"Cidade Base\", placeholder=\"Ex: S√£o Paulo\")\n+        dias_de_rota = st.number_input(\"Dias de Rota\", min_value=1, max_value=30, value=5)\n+        visitas_por_dia = st.number_input(\"Visitas por Dia\", min_value=1, max_value=20, value=8)\n+\n+    with col2:\n+        uf_base = st.selectbox(\n+            \"UF Base\",\n+            [\"SP\", \"RJ\", \"MG\", \"RS\", \"PR\", \"SC\", \"BA\", \"PE\", \"CE\", \"GO\",\n+             \"PA\", \"AM\", \"MA\", \"ES\", \"PB\", \"RN\", \"MT\", \"MS\", \"PI\", \"AL\",\n+             \"SE\", \"RO\", \"TO\", \"AC\", \"AP\", \"RR\", \"DF\"],\n+        )\n+        somente_matriz = st.checkbox(\"Apenas Matrizes\", value=False)\n+\n+    st.divider()\n+\n+    # ===== SE√á√ÉO 2: FILTROS DE LEADS =====\n+    st.markdown(\"### \" + Icons.ABA_CNAE + \" Filtros de Leads\")\n+    col1, col2 = st.columns(2)\n+\n+    with col1:\n+        segmentos_disponiveis = list(SEGMENTOS_PANTEX.keys())\n+        segmentos_labels = [SEGMENTOS_PANTEX[s].nome for s in segmentos_disponiveis]\n+        # Presets r√°pidos\n+        PRESETS = {\n+            \"Todos\": None,\n+            \"Sacaria de Rafia (recomendado)\": [\"industria_alimentos\", \"atacado_alimentos\", \"material_construcao\"]\n+        }\n+        preset = st.selectbox(\"Preset de Perfil\", options=list(PRESETS.keys()), index=1)\n+        if PRESETS.get(preset) is not None:\n+            segmentos_selecionados = [SEGMENTOS_PANTEX[k].nome for k in PRESETS[preset] if k in SEGMENTOS_PANTEX]\n+        else:\n+            segmentos_selecionados = st.multiselect(\"Segmentos de Interesse\", options=segmentos_labels)\n+        segmentos_keys = [k for k, v in SEGMENTOS_PANTEX.items() if v.nome in segmentos_selecionados]\n+\n+    with col2:\n+        cnaes_manuais = st.text_input(\"CNAEs Espec√≠ficos (opcional)\", placeholder=\"4711302,4729699\")\n+        modo_rota = st.radio(\n+            \"Modo de Rota\",\n+            options=[\"Gerar automaticamente (por densidade)\", \"Usar rota existente (lista de cidades)\"],\n+            index=0,\n+        )\n+        cidades_input = None\n+        if modo_rota.endswith(\"existente\"):\n+            op_cidades = listar_cidades_do_banco(uf_base) if uf_base else []\n+            cidades_selecionadas = st.multiselect(\"Cidades (escolha uma ou mais)\", options=op_cidades)\n+        else:\n+            cidades_input = st.text_area(\"Lista de cidades para rota (uma por linha, opcional)\", height=80)\n+\n+    st.divider()\n+\n+    # ===== SE√á√ÉO 3: GERAR ROTA =====\n+    if st.button(Icons.BUSCAR + \" GERAR ROTA\", type=\"primary\", use_container_width=True):\n+        if not cidade_base or not uf_base:\n+            st.error(Icons.ALERTA + \" Preencha a cidade base e UF!\")\n+            return\n+\n+        # Determina CNAEs\n+        cnaes_buscar: List[str] = []\n+        if cnaes_manuais:\n+            cnaes_buscar = [c.strip() for c in cnaes_manuais.split(',') if c.strip()]\n+        elif segmentos_keys:\n+            for seg_key in segmentos_keys:\n+                cnaes_buscar.extend(SEGMENTOS_PANTEX[seg_key].cnaes)\n+        else:\n+            st.error(Icons.ALERTA + \" Selecione segmentos ou informe CNAEs!\")\n+            return\n+\n+        with st.spinner(Icons.CARREGANDO + \" Gerando rota e buscando leads...\"):\n+            # Monta cidades alvo\n+            cidades_alvo: List[Tuple[str, str]] = []\n+\n+            if modo_rota.startswith(\"Gerar\"):\n+                dados_dash = buscar_dados_dashboard_executivo(\n+                    lista_estados=[uf_base], lista_cidades=None, lista_cnaes=cnaes_buscar\n+                )\n+                df_top = dados_dash.get('top10_cidades') if dados_dash else None\n+                if df_top is None or df_top.empty:\n+                    st.warning(Icons.ALERTA + \"N√£o h√° cidades suficientes para gerar rota. Ajuste filtros.\")\n+                    return\n+                for _, row in df_top.iterrows():\n+                    cidade_field = row.get('cidade_uf') or row.get('Cidade') or row.get('cidade')\n+                    if pd.isna(cidade_field):\n+                        continue\n+                    parts = str(cidade_field).split(' - ')\n+                    cidade = parts[0].strip()\n+                    uf = parts[1].strip() if len(parts) > 1 else uf_base\n+                    cidades_alvo.append((cidade, uf))\n+            else:\n+                # rota existente via multiselect de cidades quando dispon√≠vel\n+                if uf_base:\n+                    op = listar_cidades_do_banco(uf_base)\n+                    escolhas = st.multiselect(\"Cidades para rota (selecione)\", options=op)\n+                    if not escolhas:\n+                        st.warning(Icons.ALERTA + \"Forne√ßa cidades para usar a rota existente.\")\n+                        return\n+                    for escolha in escolhas:\n+                        cidades_alvo.append((escolha, uf_base))\n+                else:\n+                    linhas = [l.strip() for l in (cidades_input or \"\").splitlines() if l.strip()]\n+                    if not linhas:\n+                        st.warning(Icons.ALERTA + \"Forne√ßa cidades para usar a rota existente.\")\n+                        return\n+                    for linha in linhas:\n+                        if '-' in linha:\n+                            parts = [p.strip() for p in linha.split('-', 1)]\n+                            cidades_alvo.append((parts[0], parts[1]))\n+                        else:\n+                            cidades_alvo.append((linha, uf_base))\n+\n+            # Busca leads por cidade e seleciona\n+            leads_por_cidade: dict[str, List] = {}\n+            counts_by_city: dict[str, int] = {}\n+            total_encontrados = 0\n+            for cidade_nome, cidade_uf in cidades_alvo:\n+                leads_local = buscar_leads_enriquecidos(\n+                    lista_cnaes=cnaes_buscar, uf=cidade_uf, cidade=cidade_nome, somente_matriz=somente_matriz, limite=2000\n+                )\n+                count_local = len(leads_local) if leads_local else 0\n+                counts_by_city[f\"{cidade_nome} - {cidade_uf}\"] = count_local\n+                leads_scored = qualificar_leads(leads_local, score_minimo=0) if leads_local else []\n+                chave = f\"{cidade_nome} - {cidade_uf}\"\n+                leads_por_cidade[chave] = leads_scored\n+                total_encontrados += len(leads_scored)\n+\n+            if total_encontrados == 0:\n+                st.warning(Icons.ALERTA + \"Nenhum lead encontrado para as cidades selecionadas.\")\n+                # mostra detalhes por cidade para debugging\n+                try:\n+                    df_counts = pd.DataFrame([{'cidade': k, 'encontrados': v} for k, v in counts_by_city.items()])\n+                    st.dataframe(df_counts, use_container_width=True)\n+                except Exception:\n+                    pass\n+                return\n+            else:\n+                # mostra cidades com zero encontrados (opcional)\n+                zeros = {k: v for k, v in counts_by_city.items() if v == 0}\n+                if zeros:\n+                    st.info(f\"Algumas cidades n√£o retornaram leads: {len(zeros)} (veja tabela abaixo)\")\n+                    try:\n+                        df_zeros = pd.DataFrame([{'cidade': k, 'encontrados': v} for k, v in counts_by_city.items()])\n+                        st.dataframe(df_zeros, use_container_width=True)\n+                    except Exception:\n+                        pass\n+\n+            # Seleciona top 1 por cidade e completa por score geral\n+            selecionados: List = []\n+            for chave, lista in leads_por_cidade.items():\n+                if lista:\n+                    selecionados.append(lista[0])\n+\n+            vagas = dias_de_rota * visitas_por_dia - len(selecionados)\n+            if vagas > 0:\n+                restantes = []\n+                for lista in leads_por_cidade.values():\n+                    restantes.extend(lista)\n+                selecionados_cnpjs = {l.cnpj for l in selecionados}\n+                restantes = [l for l in restantes if l.cnpj not in selecionados_cnpjs]\n+                if somente_matriz:\n+                    restantes = dedupe_leads_por_cnpj_basico(restantes)\n+                restantes_sorted = sorted(restantes, key=lambda x: x.score, reverse=True)\n+                selecionados.extend(restantes_sorted[:vagas])\n+\n+            # Gera rota e salva\n+            rota = planejar_rota(selecionados, dias_de_rota, visitas_por_dia, cidade_base, uf_base)\n+            st.session_state['rota_planejada'] = rota\n+            st.session_state['leads_rota'] = selecionados\n+            st.success(Icons.SUCESSO + f\" Rota gerada com {rota.total_visitas} visitas em {rota.total_dias} dias!\")\n+\n+    st.divider()\n+\n+    # ===== SE√á√ÉO 4: EXIBIR ROTA =====\n+    if 'rota_planejada' in st.session_state:\n+        rota = st.session_state['rota_planejada']\n+        st.markdown(\"### \" + Icons.ABA_DASH + \" Rota Planejada\")\n+\n+        # M√©tricas\n+        col1, col2, col3, col4 = st.columns(4)\n+        col1.metric(Icons.ABA_PROSPECT + \" Total de Visitas\", rota.total_visitas)\n+        col2.metric(Icons.ABA_DASH + \" Dias de Rota\", rota.total_dias)\n+        col3.metric(Icons.LOGO_PAGINA + \" Score M√©dio\", f\"{rota.score_medio_geral:.1f}\")\n+        col4.metric(Icons.INFO + \" Cidade Base\", f\"{rota.cidade_base} - {rota.uf_base}\")\n+\n+        st.divider()\n+\n+        # Mapa aproximado por UF (centroides)\n+        coordenadas_uf = {\n+            'AC': (-9.0238, -70.8120), 'AL': (-9.5713, -36.7820), 'AP': (1.4144, -51.7865),\n+            'AM': (-4.2633, -65.2432), 'BA': (-12.9714, -38.5014), 'CE': (-3.7172, -38.5433),\n+            'DF': (-15.7942, -47.8822), 'ES': (-19.1834, -40.3089), 'GO': (-16.6864, -49.2643),\n+            'MA': (-2.5387, -44.2825), 'MT': (-15.6014, -56.0979), 'MS': (-20.7722, -54.7852),\n+            'MG': (-19.9167, -43.9345), 'PA': (-1.4558, -48.5044), 'PB': (-7.2400, -36.7820),\n+            'PR': (-25.4284, -49.2733), 'PE': (-8.0476, -34.8770), 'PI': (-5.0892, -42.8019),\n+            'RJ': (-22.9068, -43.1729), 'RN': (-5.7945, -35.2110), 'RS': (-30.0346, -51.2177),\n+            'RO': (-8.7612, -63.9039), 'RR': (1.4144, -61.4444), 'SC': (-27.2423, -50.2189),\n+            'SP': (-23.5505, -46.6333), 'SE': (-10.5741, -37.3857), 'TO': (-10.1753, -48.2982)\n+        }\n+\n+        pontos = []\n+        for dia in rota.dias:\n+            for stop in dia.stops:\n+                lead = stop.lead\n+                uf = lead.uf or rota.uf_base\n+                lat, lon = coordenadas_uf.get(uf, (-14.2350, -51.9253))\n+                pontos.append({'dia': dia.dia, 'ordem': stop.ordem, 'empresa': lead.nome_fantasia,\n+                               'cnpj': lead.cnpj, 'score': getattr(lead, 'score', 0), 'lat': lat, 'lon': lon})\n+\n+        if pontos:\n+            df_map = pd.DataFrame(pontos)\n+            try:\n+                import plotly.express as px\n+                fig = px.scatter_mapbox(df_map, lat='lat', lon='lon', color='dia', size='score',\n+                                        hover_name='empresa', zoom=5, height=400, mapbox_style='open-street-map')\n+                st.plotly_chart(fig, use_container_width=True)\n+            except Exception:\n+                df_map = df_map.rename(columns={'lat': 'latitude', 'lon': 'longitude'})\n+                st.map(df_map)\n+\n+        st.divider()\n+\n+        # Tabela por dia e downloads\n+        for dia_plan in rota.dias:\n+            with st.expander(f\"üìÖ Dia {dia_plan.dia} - {dia_plan.total_visitas} visitas (Score m√©dio: {dia_plan.score_medio:.1f})\", expanded=(dia_plan.dia == 1)):\n+                dados_dia = []\n+                for stop in dia_plan.stops:\n+                    lead = stop.lead\n+                    dados_dia.append({'Ordem': stop.ordem, 'Empresa': lead.nome_fantasia, 'CNPJ': lead.cnpj,\n+                                      'Score': getattr(lead, 'score', 0), 'Endere√ßo': lead.endereco.formatado if lead.endereco else '',\n+                                      'Telefone': lead.telefone_principal or '', 'Email': lead.email or ''})\n+                df_dia = pd.DataFrame(dados_dia)\n+                st.dataframe(df_dia, use_container_width=True, hide_index=True)\n+                if dia_plan.link_maps_rota:\n+                    st.markdown(f\"üó∫Ô∏è [Abrir rota do dia no Google Maps]({dia_plan.link_maps_rota})\")\n+\n+        st.divider()\n+        col1, col2 = st.columns(2)\n+        with col1:\n+            excel_roteiro = gerar_excel_roteiro(rota, incluir_links=True)\n+            st.download_button(label=Icons.DOWNLOAD + \" BAIXAR ROTEIRO COMPLETO\", data=excel_roteiro,\n+                               file_name=f\"Roteiro_{cidade_base}_{uf_base}.xlsx\",\n+                               mime=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\")\n+        with col2:\n+            if st.button(Icons.BUSCAR + \" NOVA ROTA\"):\n+                del st.session_state['rota_planejada']\n+                del st.session_state['leads_rota']\n+                st.rerun()\n*** End Patch"}})
